# 实验内容：
加速系统调用

在`getpid()`系统调用中实现优化，优化内容如下：
- 当进程被创建时，在`USYSCALL`所对应的虚拟地址映射一个只读的页
- 在此页的起始处存储一个`usyscall`结构体，同时初始化这个结构体，并记录当前进程的`PID`。
<font color="#ff0000">tip：</font>
- 操作系统（如linux）通过用户空间和内核空间的只读共享数据来加速特定系统调用。
- 执行这些操作消除了内核的交叉使用。

# 2、实验提示
<font color="#ff0000">1、</font>`ugetpid()`函数已经提供在用户空间中（`user/ulib.c`中)，并且会自动使用`USYSCALL`映射。
<font color="#ff0000">2、</font>设置权限bit，以使得用户空间只读此页。（参照[[Lab3-0：Page tables]]中的PTE）
<font color="#ff0000">3、</font>参照`kernel/proc.c`中的[[trapframe]]，实现新页完整生命周期所必须的操作。

# 3、分析
## <font color="#ff0000">3.1</font> `USYSCALL`虚拟地址
USYSCALL在`memlayout.h`中定义，与[[pgsize]]、[[trapframe]]和[[trampoline]]有关。此虚拟地址处于高位处，有4kb字节，刚好对应与一个页面。
```c
#define TRAPFRAME (TRAMPOLINE - PGSIZE)  //页大小为4Kb，
#define USYSCALL (TRAPFRAME - PGSIZE)
```
## <font color="#ff0000">3.2</font> 实现过程
[[结构体]]`proc`记录了每一个[[进程]]的状态，在`proc`定义中添加`usyscall`结构体指针，此指针指向共享空间中的`usyscall`结构体，结构体中记录着当前进程PID信息。
因此需要对`proc.h`中的`proc`结构体作修改，在结构体末尾添加以下内容：
```c
struct usyscall *usyscall;   //lab3.1，此处记录了指向`usyscall`结构体的指针。
```
当进程被创建时，首先建立`proc`结构体信息，其后对其进行初始化。在`allocproc`函数中，我们需要对`*usyscall`指针进行赋值，使其对应与目标`USYSCALL`虚拟地址（共享空间）。具体如下：（仿照`trapframe`的分配方法）
```c
  // Allocate lab3.1 usyscall
  if((p->usyscall = (struct usyscall *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
```







```c
int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;//将USYSCALL值强制转换成地址
  return u->pid;   //返回存储的地址
}
